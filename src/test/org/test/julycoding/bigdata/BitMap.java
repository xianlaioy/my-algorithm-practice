package org.test.julycoding.bigdata;

/**
 * 问题一：
 *      给定一个文件，里面最多含有n个不重复的正整数（也就是说可能含有少于n个不重复正整数），且其中每个数都
 *      小于等于n，n=10^7。 输出：得到按从小到大升序排列的包含所有输入的整数的列表。 条件：最多有大约1MB的
 *      内存空间可用，但磁盘空间足够。且要求运行时间在5分钟以下，10秒为最佳结果。
 * 【思路】：
 *      - 1.1 使用bitmap，1M=10^6 * 8bit，最大的数为10^7，则可以将数分为两部分，第一部分为1到5*10^6，第二部分
 *      为5*10^6+1到10^7，分两遍读取文件；
 *      - 1.2 使用内存为(5*10^6)/(8*10^6)=0.625M，第一次读取数据文件，将属于第一部分的数据读入bitmap，排序后输出，
 *      然后再次读取数据文件，将属于第二部分的数据读入bitmap，排序后输出；
 *      - 注意：bitmap的使用范围：数据不能重复，可实现快速查找、判重及删除。
 *
 * 问题二：
 *      在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数；
 * 【思路】：
 *      - 2.1 如果内存不足以容纳所有的整数，可以分而治之，将整数通过hash分为几个小部分，对每个小部分分别
 *      统计，最后汇总；
 *      - 2.2 使用2-bitmap，即使用2个bit表示一个整数，00表示不存在，01表示出现1次，10表示出现2次，11表示无意义；
 *      一个byte可以表示4个整数，则需要的内存为2.5*10^8/4≈60M左右；依次读取整数，查看bitmap中对应的位，00变01，
 *      01变10， 其它保持不变；，最后输出所有的01位即可；
 *
 * 问题三：
 *      给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？
 * 【思路】：
 *      - 使用bitmap，40亿个数据，使用1个bit表示一个整数是否存在，则需要的内存为(4*10^9)/(8*10^9)=512M即可；先
 *      依次读取40亿个整数，将bitmap中对应的bit置位，最后判断给定的数对应的bit是否为1；
 *
 *
 * @author: lingguo
 * @time: 2014/8/31 21:05
 */
public class BitMap {
}
